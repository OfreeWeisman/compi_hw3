%{
	#include <iostream>
	#include "hw3_output.hpp"
	#include "Semantics.h"
	#include "ScopesTable.h"
	#include "Tokens.h"
	using namespace std;
	int yylex();
	extern int yylineno;

	void yyerror(const char*);

	DataStructures* globalTables;
	vector<string>* funcArgs;


%}

%nonassoc	VOID
%nonassoc	INT
%nonassoc	BYTE
%nonassoc	B
%nonassoc	BOOL
%nonassoc	TRUE
%nonassoc	FALSE
%nonassoc	RETURN
%nonassoc	IF
%left	RPAREN
%nonassoc	ELSE
%nonassoc	WHILE
%nonassoc	BREAK
%nonassoc	CONTINUE
%nonassoc	SC
%nonassoc	COMMA
%left	LPAREN
%nonassoc	LBRACE
%nonassoc	RBRACE
%nonassoc	NUM
%nonassoc	ID
%nonassoc	STRING
%right		ASSIGN
%left		OR
%left		AND
%left		EQUALITY
%nonassoc	RELOP
%left		PLUS_OP
%left		MUL_OP
%right		NOT

%%

Program 	: Marker1 Funcs													{cleanup(globalTables);}
			;
Marker1     : /*epsilon*/                                                   {setup(globalTables);}
Funcs		: /*epsilon*/													{}
			| FuncDecl Funcs												{output::printProductionRule(3);}
			;
FuncDecl	: RetType ID                                                    {openScope($1,$2,globalTables,funcArgs);}
                LPAREN
                    Formals
                RPAREN
                LBRACE
                    Statements
                RBRACE		                                                {closeScope();}
			;
RetType		: Type															{$$ = semantics5($1);}
			| VOID															{$$ = semantics6();}
			;
Formals		: /*epsilon*/													{$$ = addEmptyParametersList();}
			| FormalsList													{$$ = addParametersList($1,globalTables,funcArgs);}
			;
FormalsList	: FormalDecl													{semantics9($1);}
			| FormalDecl COMMA FormalsList									{semantics10($1,$2,$3,globalTables, funcArgs);}
			;
FormalDecl	: Type ID														{semantics11($1,$2,globalTables);}
			;
Statements	: Statement														{output::printProductionRule(12);}
			| Statements Statement											{output::printProductionRule(13);}
			;
Statement : IF LPAREN Exp RPAREN Statement								    {output::printProductionRule(21);}
      |  IF LPAREN Exp RPAREN Statement ELSE Statement					    {output::printProductionRule(22);}
      |  WHILE LPAREN Exp RPAREN Statement								    {output::printProductionRule(23);}
      |  WHILE LPAREN Exp RPAREN Statement ELSE Statement				    {output::printProductionRule(24);}
      | LBRACE Statements RBRACE										    {output::printProductionRule(14);}
			| Type ID SC													{semantics15($1,$2,$3, globalTables);}
			| Type ID ASSIGN Exp SC											{output::printProductionRule(16);}
			| ID ASSIGN Exp SC												{output::printProductionRule(17);}
			| Call SC														{output::printProductionRule(18);}
			| RETURN SC														{output::printProductionRule(19);}
			| RETURN Exp SC													{output::printProductionRule(20);}
			| BREAK SC														{output::printProductionRule(25);}
			| CONTINUE SC													{output::printProductionRule(26);}
			;
Call		: ID LPAREN ExpList RPAREN												{output::printProductionRule(27);}
			| ID LPAREN RPAREN												{output::printProductionRule(28);}
			;
ExpList		: Exp															{output::printProductionRule(29);}
			| Exp COMMA ExpList												{output::printProductionRule(30);}
			;
Type		: INT															{$$ = semanticsTypeInt();}
			| BYTE															{$$ = semanticsTypeByte();}
			| BOOL															{$$ = semanticsTypeBool();}
			;
Exp			: LPAREN Exp RPAREN												{output::printProductionRule(34);}
			| Exp MUL_OP Exp												{output::printProductionRule(35);}
			| Exp PLUS_OP Exp												{output::printProductionRule(35);}
			| ID															{output::printProductionRule(36);}
			| Call															{output::printProductionRule(37);}
			| NUM															{$$ = semantics38($1);}
			| NUM B															{$$ = semantics39($1,$2);}
			| STRING														{output::printProductionRule(40);}
			| TRUE															{$$ = semanticsTrue();}
			| FALSE															{$$ = semanticsFalse();}
			| NOT Exp														{output::printProductionRule(43);}
			| Exp AND Exp													{output::printProductionRule(44);}
			| Exp OR Exp													{output::printProductionRule(45);}
			| Exp RELOP Exp													{output::printProductionRule(46);}
			| Exp EQUALITY Exp												{output::printProductionRule(46);}
			;
%%

int main(){
    //globalScopesTable = new ScopesTable();

    funcArgs = new  vector<string>();
    globalTables = new DataStructures();
	return yyparse();
}


void yyerror(const char*){
	extern int yylineno;
	output::errorSyn(yylineno);
	exit (0);
}	

