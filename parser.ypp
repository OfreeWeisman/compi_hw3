%{
	#include <iostream>
	#include "hw3_output.hpp"
	#include "Semantics.h"
	#include "ScopesTable.h"
	#include "Tokens.h"
	using namespace std;
	int yylex();
	extern int yylineno;

	void yyerror(const char*);

    using namespace std;
	DataStructures* globalTables;
	vector<string>* funcArgs;
	int inWhile;


%}

%nonassoc	VOID
%nonassoc	INT
%nonassoc	BYTE
%nonassoc	B
%nonassoc	BOOL
%nonassoc	TRUE
%nonassoc	FALSE
%nonassoc	RETURN
%nonassoc	IF
%left	RPAREN
%nonassoc	ELSE
%nonassoc	WHILE
%nonassoc	BREAK
%nonassoc	CONTINUE
%nonassoc	SC
%nonassoc	COMMA
%left	LPAREN
%nonassoc	LBRACE
%nonassoc	RBRACE
%nonassoc	NUM
%nonassoc	ID
%nonassoc	STRING
%right		ASSIGN
%left		OR
%left		AND
%left		EQUALITY
%nonassoc	RELOP
%left		PLUS_OP
%left		MUL_OP
%right		NOT

%%


Program 	: Marker1 Funcs													{cleanup(globalTables);}
			;
Funcs		: /*epsilon*/													{}
			| FuncDecl Funcs												{}
			;
FuncDecl	: FuncDeclOpen FuncDeclInsert                                   {}
            ;
FuncDeclOpen: RetType ID LPAREN Formals RPAREN                              {cout<<"before"<<endl; openFuncScope($1,$2,globalTables,funcArgs);cout<<"after"<<endl;}
            ;
FuncDeclInsert :LBRACE Statements Marker_close RBRACE                       {cout<<"end of empty body"<<endl;}
            ;
RetType		: Type															{$$ = semantics5($1);}
			| VOID															{cout<<"retype void"<<endl; $$ = semantics6();}
			;
Formals		: /*epsilon*/													{cout<< " end of empty formals"<<endl;}
			| FormalsList													{cout<< "one formal"<<endl; $$ = addParametersList($1,globalTables,funcArgs);}
			;
FormalsList	: FormalDecl													{$$ = semantics9($1);}
			| FormalDecl COMMA FormalsList									{$$ = semantics10($1,$2,$3,globalTables, funcArgs);}
			;
FormalDecl	: Type ID														{cout<<"type id"<<endl; $$ = semantics11($1,$2,globalTables);}
			;
Statements	: Statement														{cout<<"statement"<<endl;}
			| Statements Statement											{cout<<"statements statement"<<endl;}
			;
Statement : IF LPAREN Exp RPAREN Marker_open Statement Marker_close			{semantics21($3);}
      |  IF LPAREN Exp RPAREN Marker_open Statement Marker_close ELSE Marker_open Statement Marker_close					    {semantics22($3);}
      |  WHILE LPAREN Exp RPAREN Marker_open Statement Marker_close		    {semantics23($3);}
      |  WHILE LPAREN Exp RPAREN Marker_open Statement Marker_close ELSE Marker_open Statement Marker_close				    {semantics24($3);}
      | LBRACE Marker_open Statements Marker_close RBRACE					{semantics14($3);}
			| Type ID SC													{cout<<"15"<<endl;semantics15($1,$2,$3, globalTables);}
			| Type ID ASSIGN Exp SC											{cout<<"16"<<endl;semantics16($1,$2,$3,$4,$5, globalTables);}
			| ID ASSIGN Exp SC												{cout<<"17"<<endl;semantics17($1,$2,$3,$4);}
			| Call SC														{cout<<"18"<<endl;semantics18($1,$2);}
			| RETURN SC														{cout<<"19"<<endl;semantics19($1,$2,globalTables);}
			| RETURN Exp SC													{cout<<"20"<<endl;semantics20($1,$2,$3,globalTables);}
			| BREAK SC														{cout<<"25"<<endl;semantics25($1,$2,inWhile);}
			| CONTINUE SC													{cout<<"26"<<endl;semantics26($1,$2,inWhile);}
			;

Marker_open     : /*epsilon*/                                               {openScope(globalTables);cout << "marker open returned" << endl;}

Call		: ID LPAREN ExpList RPAREN										{cout << "call? " <<endl; semantics27($1,$2,$3,$4,globalTables);}
			| ID LPAREN RPAREN												{cout<< "empty call?"<<endl; semantics28($1,globalTables);}
			;
ExpList		: Exp															{$$ = semantics29($1);}
			| Exp COMMA ExpList												{$$ = semantics30($1,$2,$3);}
			;
Type		: INT															{$$ = semanticsTypeInt();}
			| BYTE															{$$ = semanticsTypeByte();}
			| BOOL															{$$ = semanticsTypeBool();}
			;
Exp			: LPAREN Exp RPAREN												{$$ = semantics34($1,$2,$3);}
			| Exp MUL_OP Exp												{$$ = semantics35($1,$2,$3);}
			| Exp PLUS_OP Exp												{$$ = semantics35($1,$2,$3);}
			| ID															{cout<<"36"<<endl; $$ = semantics36($1);}
			| Call															{$$ = semantics37($1);}
			| NUM															{$$ = semantics38($1);}
			| NUM B															{$$ = semantics39($1,$2);}
			| STRING														{$$ = semantics40($1);}
			| TRUE															{$$ = semanticsTrue();}
			| FALSE															{$$ = semanticsFalse();}
			| NOT Exp														{$$ = semantics43($2);}
			| Exp AND Exp													{$$ = semantics44($1,$2,$3);}
			| Exp OR Exp													{$$ = semantics45($1,$2,$3);}
			| Exp RELOP Exp													{$$ = semantics46($1,$2,$3);}
			| Exp EQUALITY Exp												{$$ = semantics46($1,$2,$3);}
			;


Marker1         : /*epsilon*/                                               {cout << "marker1" << endl;setup(globalTables);}
Marker_close    : /*epsilon*/                                               {closeScope(globalTables);}

%%

int main(){
    cout<<"in main"<<endl;
    funcArgs = new vector<string>();
    globalTables = new DataStructures();
    inWhile = 0;
	return yyparse();
}


void yyerror(const char*){
	extern int yylineno;
	output::errorSyn(yylineno);
	exit (0);
}	

